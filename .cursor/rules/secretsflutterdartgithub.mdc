---
alwaysApply: true
---
## Security Rules for Secrets Management

### Core Principles
- Never commit secrets directly in code or version control
- Validate all inputs** to prevent injection attacks
- Implement defense in depth for sensitive operations
- Follow least privilege principle for API keys and service accounts

### Secrets Handling
1. Environment Variables:
   - Use `flutter_dotenv` for development secrets
   - Store in `.env` file (add to `.gitignore`)
   - Example `.env`:
     ```
     FIREBASE_API_KEY=your_key_here
     ```

2. Firebase Configuration:
   - Initialize Firebase using platform-specific secrets:
   ```dart
   FirebaseOptions(
     apiKey: const String.fromEnvironment('FIREBASE_API_KEY'),
     // Other configs...
   )
CI/CD Integration:

Inject secrets through build environment variables

Use secret managers (GitHub Secrets, GitLab CI Variables)

Secure Architecture Patterns
Repository Layer Protection:

dart
abstract class AuthRepository {
  Future<Either<AuthFailure, Unit>> secureOperation(
    String sensitiveInput // Validated input only
  );
}
ViewModel Validation:

dart
class AuthViewModel extends ChangeNotifier {
  Future<void> sensitiveAction(String input) async {
    // Input validation first
    if (!_isValid(input)) {
      _state = AuthError(ValidationFailure());
      notifyListeners();
      return;
    }
    // Proceed with validated input
  }
}
Defensive Programming:

Validate all external inputs

Sanitize outputs

Use type-safe parameters

Git Protection
Essential .gitignore:

text
# Secrets
.env
*.keystore
*.jks
key.properties
GoogleService-Info.plist
google-services.json
Pre-commit Hook (optional):

Add secret scanning with gitleaks or similar

Emergency Response
If secrets are exposed:

Rotate ALL compromised credentials immediately

Audit all access logs

Force re-authentication for affected users

Implementation Example
Secure Repository Implementation
dart
class SecureAuthRepository implements AuthRepository {
  final AuthRemoteDataSource remoteSource;
  final InputValidator validator;

  @override
  Future<Either<AuthFailure, Unit>> sensitiveOperation(
    String sensitiveInput
  ) async {
    // Always validate before processing
    if (!validator.isValid(sensitiveInput)) {
      return Left(AuthFailure.invalidInput());
    }

    return remoteSource.sensitiveOperation(sensitiveInput);
  }
}
ViewModel with Input Validation
dart
class AuthViewModel extends ChangeNotifier {
  final AuthRepository repository;
  final InputValidator validator;

  AuthState _state = AuthInitial();
  AuthState get state => _state;

  Future<void> handleSensitiveData(String input) async {
    if (!validator.isValid(input)) {
      _state = AuthError(ValidationFailure());
      notifyListeners();
      return;
    }

    _state = AuthLoading();
    notifyListeners();

    final result = await repository.sensitiveOperation(input);
    
    _state = result.fold(
      (failure) => AuthError(failure),
      (success) => AuthSuccess(),
    );
    notifyListeners();
  }
}
Secure Firebase Initialization
dart
void main() async {
  await dotenv.load(fileName: '.env');
  
  await Firebase.initializeApp(
    options: FirebaseOptions(
      apiKey: dotenv.env['FIREBASE_API_KEY'] ?? '',
      appId: dotenv.env['FIREBASE_APP_ID'] ?? '',
      // Other required configs...
    ),
  );

  runApp(
    MultiProvider(
      providers: [
        Provider<AuthRepository>(
          create: (_) => SecureAuthRepository(
            remoteSource: FirebaseAuthDataSource(),
            validator: InputValidator(),
          ),
        ),
      ],
      child: MyApp(),
    ),
  );
}